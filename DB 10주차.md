![IMG_3258](https://github.com/user-attachments/assets/884534d8-f81b-429e-a925-a58a08451e63)## Specialization

**1. Top-down Design Process (상향식 설계 과정)**

Entity 집합을 **더 구체적인 하위 Entity로 나누는 과정**이다 

상위 Entity에서 공통 속성을 유지하면서, 특정 조건에 맞춰 세부 Entity로 구분한다

ex: Person → Student, Instructor, Staff 로 세부적 Entity로 표현 구분 가능 

<br/>

**2. Lower-level Entity Sets (하위 엔티티 집합)**

상위 Entity에서 **일부 특징에 맞춰 나누어진 Entity 집합**이다 

**상위 Entity가 가지지 않은 속성이나 관계를 가질 수 있다**

ex: Person에서 Instructor는 salary 속성을 가질 수 있지만, Student는 가지지 않을 수 있다

<br/>

**3. ISA 관계**

ISA 관계 (IS A 관계): 상위 Entity가 하위 Entity로 세분화될 때 사용한다

ex: Instructor is a Person

ERD 상에서는 삼각형 위에 ISA가 표기된다

<br/>

**4. Attribute Inheritance (속성 상속)**

하위 Entity는 상위 Entity의 **모든 속성과 관계를 상속을 받는다**

상위 엔티티의 속성을 **하위 엔티티가 그대로 사용할 수 있다**

ex: Person이 name, birthdate를 가지고 있다면, Student와 Instructor는 따로 정의하지 않아도 name, birthdate를 자동으로 상속받는다 

<br/>

## Specialization 예시 

![IMG_3251](https://github.com/user-attachments/assets/b6ba4b3d-7a51-4733-8c91-7c7f70cc7ec8)

<br/>

## Specialization 구현 방법 

**방법 1**

**상위 Entity**와 **하위 Entity**를 각각 별도의 테이블로 구성

![IMG_3252](https://github.com/user-attachments/assets/0075a34f-b946-44c9-ad5f-710d4c1abc74)

<br/>

**방법 2**

각 하위 Entity가 상위 Entity의 **모든 속성을 자신의 테이블에 포함하는 방식**

![IMG_3253](https://github.com/user-attachments/assets/fba0e551-cdc9-4e46-aedf-972d32bbdbf4)

<br/>

## Generalization


Generalization은 여러 개의 하위 Entity들을 묶어서 **공통된 상위 Entity로 일반화하는 과정**(Bottom-up Design Process)이다

ex: Student, Employee → Person

즉, Generalization **Specialization은 반대 개념**이다

- **Generalization**: 여러 엔티티를 하나로 통합 → Bottom-up Approach

- **Specialization**: 하나의 엔티티를 여러 개로 세분화 → Top-down Approach

ER 다이어그램(ERD)에서는 표현 방식이 동일하고 둘 다 삼각형 ISA 관계로 연결된다

<br/>

## Completeness Constraint

**Completeness Constraint** : **상위 Entity가 반드시 하나 이상의 하위 Etity에 속해야 하는지**를 결정하는 제약 조건

Completeness Constraint는 다음과 같이 두 가지 경우가 존재한다 

- **Total (전체 포함)** : 모든 상위 Entity가 반드시 하위 Entity 중 하나에 속해야 함 (ex: 모든 Person은 반드시 Student, Employee, Instructor 중 하나여야 한다)

- **Partial (부분 포함)** : 상위 Entity가 하위 Entity에 속하지 않을 수도 있음 (ex: 일부 Person은 학생도 아니고, 직원도 아닐 수 있다)

일반적으로 **Partial 방식이 default 값이다**

<br/>

## Aggregation(집합)

만약 특정 학생의 프로젝트를 특정 교수가 평가하는 예시를 살펴보자 

**Aggregation을 사용하지 않은 예시**

![IMG_3255](https://github.com/user-attachments/assets/58d1a44d-d78e-4cef-a5ef-53ed608b9966)

위 예시를 보면 논리적인 오류는 없지만 이것을 구현하면 중복된 데이터 문제가 발생한다 

<br/>

학생 ID가 S301인 학생이 교수 ID가 I201인 교수에게 프로젝트를 평가받은 스키마를 다음과 같다고 하자 

![image](https://github.com/user-attachments/assets/246af2c0-4353-4d0e-9c7c-958c1a5f33a1)

이렇게 Aggregation 없이 Table를 만들면, project_id	instructor_id	student_id는 **변하지 않고 계속 중복이 이루어지게 된다**

<br/>

## Aggregation 사용 예시

**Aggregation은 큰 직사각형으로 표현**

![IMG_3256](https://github.com/user-attachments/assets/6125c0ae-934c-4b3a-9792-5525b5aa6416)

만약 다음과 같이 Aggregation을 이용하여 집합을 표현하면 다음과 같은 table이 만들어진다 

![image](https://github.com/user-attachments/assets/8262ac59-6052-4c12-8809-d2731d5cf364)

proj_guide를 하나로 묶어서 따로 관리를 하면, 이것을 참조만 하여 사용해도 되므로, 데이터를 중복하여 표현하는 것보다 **공간이 절약되어 훨씬 효율적이다**

<br/>

## Entities vs. Attributes

다음과 같이 instrutor table이 있다고 가정하자

![IMG_3259](https://github.com/user-attachments/assets/469b4000-3924-44b1-81a8-1118138e09ef)

만약 교수의 번호가 2개라면 아래와 같이 표현하는게 효과적이다 

![IMG_3260](https://github.com/user-attachments/assets/527a22c4-ce56-48cb-8249-6f9ff9247ee9)













































































