## 좋은 관계형 설계의 특징

좋은 Relation Design 설계란 **중복을 최소화하는 것이다**

**좋은 Relation Design 예시**

아래 예시는 각 sec_id 로 개별적으로 분리되어 있어서 중복된 데이터가 많이 없다 

![image](https://github.com/user-attachments/assets/e321b571-f4ac-4de2-b44c-1e0d57422a0c)

<br/>

**중복이 많은 Relation Design 예시**

아래 예시에서 instructor table과 department table을 in_dept table로 합치면 그림과 같이 중복 문제가 발생한다 (논리적으로 증명은 아래에서)

![IMG_3268](https://github.com/user-attachments/assets/71e3129c-aefe-4de2-9a12-ac6025f237cf)

in_dep 스키마에서 발생하는 정보 중복 문제를 피하는 유일한 방법은, **그것을 두 개의 스키마로 분해하는 것**이다. 이것을 **Decomposition** 이라고 한다

<br/>

## Decomposition

분해를 하여 중복을 없앨 수 있지만 **모든 분해가 좋은 것은 아니다**.

예를 들어 employee(ID, name, street, city, salary) 테이블을 다음과 같이 분해한다고 가정해보자

- ID와 name만 있는 employee1,

- name 기반의 나머지 정보가 있는 employee2

<br/>

이 경우 **동일한 이름을 가진 직원이 두 명 있을 경우 문제가 발생**한다

employee2에서 이름이 Kim으로 동일한 두 사람이 존재할 때, 구별을 하기 위해 각각의 ID가 필요한데, employee1을 참고해도, **어떤 사람의 ID인지 구분할 수가 없다**

이것을 판단하는 기준을 Lossy Decomposition (잘못된 분해) 파트에서 알아보자 

<br/>

## Lossy Decomposition (잘못된 분해)

**Lossy Decomposition (잘못된 분해)** : 분해 후 조인을 했더니 기존의 table보다 정보가 늘어나버렸다면, 이건 **잘못된 분해(losssy decomposition)** 이다

![IMG_3269](https://github.com/user-attachments/assets/4cc60b7a-c1f0-4ce9-8866-707a7d598478)

위 상황은 분해할 때 name을 기준으로 분해했는데, **name은 유일하지 않아서** 문제가 발생했다 

즉, **이름만 가지고는 ID를 구별할 수 없는데**, 그걸로 join 했기 때문에 문제가 발생한 것이다

<br/>

## Lossless decomposition (손실 없는 분해)

관계 스키마 R이 있고, R1과 R2가 R의 분해(decomposition)를 이룬다고 하자

이때  Lossless decomposition (손실 없는 분해)는 테이블을 나눴다가 다시 합쳐도, **원래 테이블이 완전히 똑같이 복원되는 분해이다**

즉, 아래 공식을 만족해야한다 

![image](https://github.com/user-attachments/assets/6d00c163-7832-4feb-8d63-35f8c487d363)

-> 원래 테이블 r을 속성 기준으로 두 개로 나누고(R₁, R₂), 이 두 개를 다시 natural join을 했을 때, 기존의 table과 같다면 Lossless decomposition이다  

<br/>

**예시**

![image](https://github.com/user-attachments/assets/c8113036-2cc9-4f8e-b8c1-6390703385f6)

<br/>

반대로, Lossy Decomposition(잘못된 분해)의 공식은 다음과 같다 

![image](https://github.com/user-attachments/assets/51a1ec45-5836-491c-9a10-580180e74b9d)

-> 두 테이블로 나눴다가 다시 조인했는데, **원래보다 더 많은 결과가 나온 것**

<br/>

## 정규화 이론 

특정 릴레이션 R이 테이블이 중복 많고 구조가 이상하면 **쪼개서 정리**해야 한다 

이때, 여러 개의 작은 테이블로 분리하되, **정보가 빠지거나 중복이 되면 안된다**

그래서 **정규화 이론**이 필요하고, 이 이론은 **종속성 개념(FD, MVD)** 에 기반해 있다

**정규화 이론** : 해당 테이블이 좋은 테이블인지 판단하는 이론 

1. **Functional dependencies(함수 종속성)** : 한 속성이 다른 속성을 결정짓는 관계 (ex: 학번이 같으면 이름도 같아야 한다. 이런 관계를 바탕으로 정규화를 함)

2. **Multivalued dependencies(다치 종속성)** : 하나의 속성이 여러 개의 독립된 값을 가질 수 있을 때 (ex: 한 학생이 여러 전화번호를 가질 수 있는 상황처럼,
속성이 여러 개의 값을 가질 때 생기는 이상 현상도 처리 대상)

<br/>

이것을 하나씩 자세하게 살펴 보자 

<br/>

## Functional Dependencies (함수 종속성)

실제 데이터에는 반드시 지켜야 하는 논리적 규칙이 많다. 예: 학번은 유일해야 함

**예시**

1.  ID는 사람을 고유하게 구분한다.  즉, ID → 이름 같은 관계가 성립한다.-

2.  하나의 ID에 여러 이름이 붙을 수는 없다

3.  사람은 기본적으로 하나의 학과에만 소속되어 있다. 즉, ID → 학과명

4. 학과명이 같으면 예산과 건물도 반드시 같다

<br/>

**legal instance(합법 인스턴스)** : 현실의 제약 조건을 모두 만족하는 관계

데이터베이스의 모든 테이블이 합법 인스턴스면, 전체 DB도 합법이다 

<br/>

**legal relations(합법적인 관계)가 되기 위한 조건**

1. 어떤 속성 집합이 다른 속성 집합의 값을 유일하게 결정해야 한다. A 값이 같으면, B 값도 **무조건 같아야 한다**는 조건. 이것이 바로 **Functional Dependencies (함수 종속성)** 이다

2. Functional Dependencies (함수 종속성)은 키 개념의 일반화이다. 쉽게 말해 키는 유일성만 보장하지만, 함수 종속은 **일관성까지 보장**하는 더 일반적인 개념

<br/>

릴레이션 스키마 R가 있다고 하자

-  α ⊆ R and β ⊆ R

이때, Functional Dependencies (함수 종속성)의 표현은 다음과 같이 한다 

![image](https://github.com/user-attachments/assets/58cb0c80-75e4-43f9-b235-b2ea598ad087)

함수 종속 𝛼 → 𝛽는 다음 조건을 만족하면 성립한다

여기서 t는 튜플이고 안에 값은 속성을 의미한다 

![image](https://github.com/user-attachments/assets/1f461b25-06d3-47fe-93de-e001806382a3)

즉, 같은 α 값을 가진 두 튜플이 있다면, **반드시 β 값도 같아야 한다는 뜻**

<br/>

**예시**

![IMG_3353](https://github.com/user-attachments/assets/6267fcf2-ec10-4048-98e0-d6d1c519902e)

<br/>

## Functional Dependencies (함수 종속성) 주의할 점 

classroom(building, room_number, capacity)라는 테이블이 있다고 가정하자 

![image](https://github.com/user-attachments/assets/9ced7423-eb0e-409e-959a-4675e508568d)

해당 테이블은 건물 이름과 호실이 겹치지 않도록 설계된 테이블이다. Watson 건물에만 100호와 120호가 있고, 나머지는 건물마다 유일한 room_number를 가진다

여기서 주의할 점은 room_number → capacity는 **우연히 성립한다는 것**이다. 

표에서 보면 room_number가 유일해서 용량(capacity)을 결정짓는 것처럼 보이지만, 이는 우연일 뿐이고 실제로는 다른 건물에 있는 호수의 capacity가 다를 수 있다

따라서 이것은 **진정한 함수 종속은 아니다**

<br/>

## 함수 종속 집합의 닫힘(Closure)

함수 종속 집합 F가 주어졌을 때, F로부터 논리적으로 유도될 수 있는 다른 함수 종속들이 존재한다

쉽게 말해, 우리가 명시적으로 알지 못해도 기존 종속성들을 조합하면 자연스럽게 따라오는 종속성들이 있다는 의미이다 

ex: 만약 A → B이고 B → C라면, A → C도 유도할 수 있다

이렇게 **F로부터 논리적으로 유도될 수 있는 모든 함수 종속의 집합**이 바로 F의 **닫힘(closure)** 이다

F의 닫힘은 **F⁺로 표기한다**

<br/>

## Key & Functional Dependencies (함수 종속성)

K가 릴레이션 스키마 R의 super key가 되기 위한 조건은 오직 K → R일 때이다

![image](https://github.com/user-attachments/assets/922f00ff-3e33-4c70-aafc-dcd88b1cb189)





























