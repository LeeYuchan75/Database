## index 기본 개념 

**indexing** 메커니즘은 **원하는 데이터에 더 빠르게 접근하기 위해** 사용된다

ex: 도서관에서 책을 빠르게 찾기 위해 '저자 목록'이 있는 것처럼, 데이터베이스에서도 인덱스를 사용하면 데이터를 빨리 찾을 수 있어요

- **Search Key** : 파일에서 레코드를 찾기 위해 사용하는 하나 또는 여러 개의 속성 (보통 primary key로 둠)

- **index file** : 여러 레코드로 이루어져 있으며, 이 레코드들을 **index entry**라고 부른다

- index file은 일반적으로 원래 파일보다 훨씬 작다

<br/>

### 두 가지 기본적인 인덱스 유형

- **Ordered index** (Ordered indices): 검색 키들이 **정렬된 순서대로** 저장

- **Hash indices** (Hash indices) : Hash index는 해시 함수로 만든 값들을 버킷에 고르게 분산시킨다

<br/>

### 인덱스 평가 지표 

- **Access time** : 특정 데이터를 찾는 데 걸리는 시간

- **Insertion time** : 새로운 데이터를 넣는 데 걸리는 시간 + 인덱스를 갱신하는 시간

- **Deletion time** : 데이터를 삭제하는 데 걸리는 시간 + 인덱스를 갱신하는 시간

- **Space overhead** : 인덱스를 저장하기 위해 추가로 필요한 공간

<br/>

<br/>

### Ordered Indices

Ordered index는 검색 키 값을 기준으로 정렬된 순서로 인덱스 항목들을 저장함

개념 자체는 primary index와 secondary index를 서로 비교하고 Dense index 와 Sparse index를 비교하는게 이해하기 편하다 

하나씩 살펴보자 

<br/>

### Primary index 

- 파일이 순차적으로 정렬되어 있을 때, 그 정렬 순서를 결정하는 검색 키에 대한 인덱스 

- ex: 파일 자체가 학번 순이면, 학번이 primary index 기준), 반드시 **primary key를 index로 잡지 않아도 됨**

- clustering index라고도 부름

- **Index-sequential file** : 검색 키 순서대로 정렬된 파일 + 그 키에 대한 primary index


<br/>

### Secondary index

- 파일이 정렬된 순서와 **다른 기준으로** 만든 인덱스

- ex: 파일은 학번 순인데, 전공(dept_name)으로 찾고 싶을 때 필요

- non-clustering index라고도 함

<br/>

###  Dense Index Files

**Dense index** : 파일에 존재하는 모든 검색 키 값에 대해 인덱스 항목이 존재함

**Dense Index Files** : Dense Index를 파일로 구성한 전체 구조

![image](https://github.com/user-attachments/assets/a610fa80-24d3-41c2-9e2c-9632e563a7a9)

- 인덱스를 통해 ID만 알면 곧바로 해당 레코드 위치로 갈 수 있음

- **장점** : 레코드를 찾는 **속도가 빠르다**

- **단점** : **공간**을 많이 차지한다

<br/>

### Sparse Index Files

**Sparse Index** : 일부 검색 키 값에 대해서만 인덱스 항목을 포함

![image](https://github.com/user-attachments/assets/259fc00a-0b30-47ad-9de2-ee287d80e3ff)

**Sparse Index 동작 방식** : 만약 찾고자 하는 레코드가 있을 때 인덱스들 중 해당 레코드보다 같거나 작은 인덱스 중 가장 큰 인덱스에서 시작하여 가아가는 방식

<br/>

### Sparse Index 예시 

문제 : ID가 15151를 찾고 싶다

현재 포인터는 10101, 32343, 76766만 가리키고 있음

해당 ID는 순차적으로 정렬되어있기 때문에 

15151보다 같거나 작은 인덱스 중 가장 큰 인덱스는 10101이다 

따라서 10101에서 찾아 올라가며 15151를 찾는 방식 

<br/>

### 좋은 절충안 (Good tradeoff)

Dense index 방식은 레코드를 찾는 속도가 빠르지만 공간을 많이 차지한다는 단점이 존재하고 

Sparse index 방식은 공간을 절약할 수 있지만, Dense index에 비해 상대적으로 느리다는 단점이 존재한다 

두 장단점을 이용하여 다음과 같은 절충안을 이용할 수 있다 

<br/>

절충안 : **블록 하나하나를 대표하는 인덱스**만 두는 방식

![image](https://github.com/user-attachments/assets/3fa23f95-d264-4990-8b2e-3887675d8049)

Sparse index에서 index는 10개의 레코드마다 index를 둘 수 있는 것처럼 다양한 전략이 있지만 

여기서는 Sparse index의 범위를 **대표로 지정**하는 것이다  

<br/>

### 좋은 절충안 (Good tradeoff) 예시

다음과 같이 block 하나의 4개의 ID가 있다고 가정하자 

여기서 block에 대해 설명하자면, 디스크는 데이터를 한 바이트씩 읽지 않고, 몇 KB~수십 KB씩 묶어서 한 번에 읽는다 

이 묶음 단위를 **block**이라고 함 (block은 4KB, 즉 한번에 4KB 씩 읽어드림)

<br/>

블록 번호와 레코드 (ID 기준) 가정

- Block 0 : 10101, 11111, 12121, 13131

- Block 1 : 14141, 15151, 16161, 17171

- Block 2 : 18181, 19191, 20101, 21111

<br/>

위 예시에서 만약 Dense Index 방식이라면 각 ID에 대해 인덱스가 있어야 한다 

- 10101, 11111, 12121, 13131, ..., 21111 → 총 12개

<br/>

하지만 Good tradeoff 방식을 사용하면, **각 블록에서 가장 작은 ID 값만 인덱싱함**

- 10101 -> Block 0 

- 14141 -> Block 1

- 18181 -> Block 2

<br/>

이걸 이용하면 ID가 15151인 교수는 이렇게 찾을 수 있다 

1. 인덱스에서 15151보다 작거나 같은 가장 큰 값 찾음 → 14141

2. 이 인덱스는 Block 1을 가리킴

3. Block 1으로 가서 15151이 있는지 한 칸씩 순차적으로 확인

<br/>

### Secondary Index

**Secondary Index** : 파일이 정렬되어 있지 않은 속성(attribute)으로도 빠르게 검색할 수 있게 만들어주는 인덱스

ex : 교수 테이블이 ID 순으로 정렬되어 있다고 하자, 이 경우 ID로 검색하는 건 금방 할 수 있음 → 이것이 Primary Index

하지만 급여(salary)가 80000인 교수를 찾고 싶을 수 있음 → ID 순으로는 정렬돼 있지 않기 때문에 빠르게 찾기 어려움 -> 그래서 만든 게 **Secondary Index** 이다 

이것을 이용하여 salary에 대한 secondary index를 만들면 salary에 대해 정렬된다 

<br/>

![image](https://github.com/user-attachments/assets/3ca46481-ab33-45e0-96fa-e5d3bb9164cb)

위 예시는 ID로 정렬된 것을 salary에 대한 secondary index를 만든 것이다 

<br/>




































































