## aggregate functions(집계 함수)

## AVG()

avg() : 지정한 컬럼 값의 평균을 계산

```ruby
SELECT AVG(population) AS avg_population
FROM country;
```

![image](https://github.com/user-attachments/assets/9c231633-2c27-4826-971b-4f75ce45385a)

<br/>

## MIN() 

min() : 컬럼 값 중 가장 작은 값을 반환

```ruby
SELECT MIN(population) AS smallest_population
FROM country;
```

![image](https://github.com/user-attachments/assets/6a57b31c-cc5c-48ca-937b-94c111dd7685)

<br/>

## MAX()

max() : 컬럼 값 중 가장 큰 값을 반환

```ruby
SELECT MAX(population) AS largest_population
FROM country;
```

![image](https://github.com/user-attachments/assets/783097bb-9e22-401e-a35a-88e19db7c71a)

## SUM()

sum() : 지정한 컬럼 값의 총합을 계산

```ruby
SELECT SUM(population) AS total_population
FROM country;
```

![image](https://github.com/user-attachments/assets/81a1bee0-2e0c-492d-b057-c8a5795bb777)

## COUNT()

count() : 행(row)의 수를 셈

```ruby
SELECT COUNT(*) AS asian_country_count
FROM country
WHERE continent = 'Asia' AND population < 50000000;
```

![image](https://github.com/user-attachments/assets/7f568e70-aa84-4008-a219-5593ad5b6788)

<br/>

## Gruop by & HAVING

GROUP BY : 행들을 특정 컬럼 값 기준으로 묶어서 집계 함수를 적용할 수 있게 함

having : GROUP BY로 묶인 그룹에 조건을 걸기 위해 사용

**WHERE는 묶기 전에 조건, HAVING은 묶은 후 조건**

<br/>

## 예시

```ruby
SELECT continent, COUNT(*) AS republic_count
FROM country
WHERE GovernmentForm LIKE '%Republic%'
GROUP BY continent
HAVING COUNT(*) >= 20;
```

직관적 해석 : 정부형태에 "Republic"이 포함된 나라들 중, 각 대륙별로 20개 이상인 경우만 출력

<br/>

만약 group by 없이 집계 함수를 표현한다면 ?

```ruby
오류코드
select dept_name, count(*) as count_dept_name
from instructor ;
```

컴퓨터의 해석 : count를 통해 모든 요소를 묶었는데 dept_name 값에 따라 어떻게 분배를 해야할지 혼동함 

예를 들면, 우리가 select로 dept_name과 course_id를 출력하면, dept_name에 해당하는 course_id가 서로 연결된 튜플로 출력된다 

하지만 dept_name, count(*) 이렇게 group by 없이 표현한다면, count에서 모든 열을 통합했기 때문에 dept_name마다 단일 값이 나오지 않음 

이 상황에서 dept_name에 맞는 값은 찾을 수 가 없음(이미 합쳐버렸기 때문)

따라서 group by를 통해 명시해야 오류를 피할 수 있음 







































































































 
