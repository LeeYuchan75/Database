## unique 

unique : 중복 제거 코드 

```ruby
 select T.course_id
 from course as T
 where unique ( select R.course_id
                           from section as R
                           where T.course_id= R.course_id 
                                       and R.year = 2017);
```

위와 동일한 표현은 아래와 같음 

```ruby
select course_id
from section
where year = 2017
group by course_id
having count(*) = 1;
```

위 코드는 section 테이블의 primary key가 course_id, sec_id, semester, year 로 설정되어서 반드시 하나만 나옴 

따라서 group by를 해도 하나만 나오기 때문에 unique와 같은 역할 

<br/>

4주차 실습 p.26,27 코드 입력 해보기 

<br/>

## with 

**with :  임시 테이블을 만들고, 그 결과를 본 쿼리에서 마치 테이블처럼 재사용할 수 있게 해주는 기능**

<br/>

## 예시 코드 

```ruby
with continent_country_count(continent, country_count) as (
  select continent, count(*)
  from country
  group by continent
),
max_country_count(value) as (
  select max(country_count)
  from continent_country_count
)
select continent, country_count
from continent_country_count, max_country_count
where continent_country_count.country_count = max_country_count.value;
```

continent_country_count 를 기준으로 설명하면, continent_country_count는 **table 이름**, continent와 country_count는 각각 **열의 이름**이다

with를 통해 임시 테이블을 만들 때, 첫번째 임시 테이블의 열인 country_count를 아래 max_country_count에서처럼 이용할 수 있다

또한, 마지막 select문에서 continent와 country_count의 table 이름을 명시하지 않은 이유는 from에서 가져온 테이블 중 위 두개의 열이 모두 continent_country_count에만 존재하기 때문이다 (max_country_count에는 없음) 

<br/>

이렇게 되면 sql 입장에서 혼동하지 않음

만약 **from에서 가져온 table에 공통된 열 이름이 있다면 table.열 이름으로 명시해야함**

<br/>

## Scalar Subquery

**Scalar subquery : 단일 값을 반환하는 서브쿼리**

이 개념은 예시를 통해 설명하는게 더 쉬워서 아래에 예를 제공함 

<br/>

## 예시 

```ruby
## 옳은 예
select dept_name,
       (select count(*)
        from instructor
        where department.dept_name = instructor.dept_name)
       as num_instructors
from department;

## 틀린 예

select dept_name,
       (select ID
        from instructor
        where department.dept_name = instructor.dept_name)
       as num_instructors
from department;
```

위 코드에서 dept_name과 내부 서브 쿼리를 통해 count를 출력하고자 한다 (총 2개의 열 출력)

옳은 예의 결과 table를 생각해보면 dept_name에 부서 이름이 올 것이고, count(*) 에 각 부서에 해당하는 교수의 총 인원이 나올 것이다 

반면에, 틀린 예를 살펴보면, dept_name에 부서가 하나만 오는데 ID는 교수들의 모든 ID를 가져와야 하므로 2개 이상인 데이터가 올 수 있다 

<br/>

쉽게 풀이를 생각하는 방법은, 머리속으로 그리면서 접근하는 것이다

틀린 예의 서브 쿼리만을 table로 표현한다고 했을 때, 각 부서마다 교수 ID가 2개 이상 나열될 수도 있다 

이후 외부 쿼리인 dept_name 결합하여 생각해보는 것이다 

**"부서는 하나인데 ID가 여러개면 어떻게 표현하지?" -> 오류**

<br/>

**즉, 이 경우에 반드시 단일 값으로 표현이 되어야 한다 -> 이것이 Scalar Subquery 개념**

<br/>

## Deletion

**deletion : 조건을 만족하는 행(튜플)을 삭제함**

```ruby
## 예시 1

delete from instructor


## 예시 2

delete from instructor
where dept_name= 'Finance’;

## 예시 3

delete from instructor
where dept_name in (select dept_name
from department
where building = 'Watson');
```

위 예시와 같이 table의 튜플을 모두 삭제할 수 있고, 조건을 통해 부분적으로 삭제할 수 있다 

여기서 **핵심은 table의 튜플 데이터만 삭제되는 것이지 table 자체가 삭제되는 것은 아니라는 것이다**

<br>

## Deletion 문제점 

Deletion을 사용하여 교수의 연봉 평균보다 적은 연봉을 받는 교수를 삭제시킬 때

1. 초기 평균: 60,000

2. 만약 Kim(55,000)이 삭제되고 남은 사람이 Lee(60,000), Park(65,000) 이라고 할 때

3. 평균 재계산: (60,000 + 65,000) / 2 = 62,500

4. 이제 Lee(60,000)도 조건에 해당 → 삭제

5. 평균 재계산: 65,000 → 또 다른 삭제가 생길 수도...

<br/>

이런 문제점이 발생한다 

sql에서는 이것을 방지하기 위해 



























