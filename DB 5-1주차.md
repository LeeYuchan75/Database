## Natural Join

**natural Join : 공통 열(column)의 이름이 같은 경우, 자동으로 그 열을 기준으로 테이블을 조인하는 문법**

중복되는 공통 열은 하나만 결과에 남긴다

```ruby
## 예시 1

SELECT country.name, city.name
FROM country NATURAL JOIN city;

## 예시 2

SELECT country.name, city.name
FROM country, city
WHERE country.ID = city.ID;
```

만약 공통된 열이 ID만 있다면, 예시 1과 예시 2는 같은 의미이다

즉, 우리가 예시 2처럼 사용한 코드가 바로 natural join이다 

<br/>

또한, **natural join은 3개 이상 결합할 수 있고, 만약 공통된 열이 2개 이상이라면, 모든 열이 동일해야 병합한다**

<br/>

```ruby
## table 3개 병합

SELECT *
FROM A
NATURAL JOIN B
NATURAL JOIN C;
```

<br/>

## natural join의 위험성 

공통 열의 정보를 **자동으로 병합하기 때문에**

**의도하지 않은 열이 자동으로 매치될 수 있음**

이것을 해결하기 위해 **JOIN ... USING 문법 사용**

<br/>

```ruby
SELECT name, title
FROM (student NATURAL JOIN takes) JOIN course USING (course_id);
```

이해를 위해 아래 기본형을 토대로 설명함 

```ruby
SELECT column1, column2, ...
FROM table1
JOIN table2
USING (common_column);
```

기본형을 보면 **table1과 table를 common_column 열을 기준으로 병합한다는 의미이다**

이때, **common_column은 table1과 table2 둘 다에 존재하고 이름도 같은 열이여야 함**

다시 처음 예시를 봐보면 

<br/>

```ruby
SELECT name, title
FROM (student NATURAL JOIN takes) JOIN course USING (course_id);
```

위 코드의 student natural join takes 부분에서 student는 course_id를 가지고 있지 않지만, takes는 가지고 있음 

이렇게 **병합을 한 기준으로 동일한 열이 있어야 하는거지 병합 전에는 한쪽 테이블에 없어도 됨**

또한 common_column은 아래와 같이 여러 열을 지정할 수 있음 

<br>

```ruby
SELECT *
FROM teaches
JOIN section
USING (course_id, sec_id, semester, year);
```

<br/>

## on

JOIN 연산에서 결합될 테이블 간의 조건을 정의할 때 사용하는 키워드로, 두 테이블 간의 일반적인 조건을 표현할 수 있다

ON 절에서 조건을 지정할 때는 일반적인 WHERE 절과 유사한 형태로 작성됨

즉, **on은 where과 역할이 동일하지만 작성 방법만 다름**

```ruby
select student.name 
from student join takes on student.id = takes.id;
```

위 코드와 같이 join으로 두 table을 연결하고, on 뒤에 조건을 걸어서 사용하는 방식이다 

위에 작성한 코드는 아래와 동치이다 

```ruby
select student.name
from student,takes
where student.id = takes.id;
```

<br/>

## Outer Join

Outer join의 기본 아이디어는 두 테이블을 조인할 때 하나를 기준으로 삼아서 해당 테이블의 데이터를 전부 유지하고 +a로 다른 테이블을 추가하는 것이다 

Outer Join은 조인 연산(join operation)의 확장된 형태로, 두 테이블의 정보를 결합할 때 매칭되지 않는 행의 정보 손실을 방지함

기본적으로 조인은 매칭되는 정보만 가져오지만, Outer Join은 한쪽 또는 양쪽 테이블의 매칭되지 않는 데이터도 함께 포함한다
 
매칭되지 않은 값은 NULL로 표시한다

<br/>

Outer Join의 종류는 크게 3가지가 있다

- Left Outer Join: 왼쪽 테이블의 데이터를 전부 유지하고, 오른쪽 테이블의 정보가 없으면 NULL로 표시

- Right Outer Join: 오른쪽 테이블의 데이터를 전부 유지하고, 왼쪽 테이블의 정보가 없으면 NULL로 표시

- Full Outer Join: 양쪽 테이블의 데이터를 모두 유지하며, 대응되는 정보가 없으면 NULL로 표시

<br/>

## 예시 

![image](https://github.com/user-attachments/assets/3f80e574-1074-4701-8fd2-acd2edf1f2b5)

course 와 prereq table를 natural join을 하면 course table의 튜플인 CS-347 행과 prereq table의 튜플인 CS-315행이 사라지게 된다 

이것을 Left Outer Join, Right Outer Join, Full Outer Join 별로 상황을 살펴보자 

<br/>

## Left Outer Join 결과

![스크린샷 2025-04-18 202418](https://github.com/user-attachments/assets/0e30250c-e143-49a9-91b0-93c4eb56bad8)

위 join된 table를 보면 course table은 유지가 된채 prereq만 결합이 된 상태이고 CS-315 튜플이 가지지 않는 열은 null로 처리함 

코드는 아래와 같다 

```ruby
select*
from course natural left join prereq;
```

<br/>

## Right Outer Join 결과 

![image](https://github.com/user-attachments/assets/f1f1427b-654f-449d-b44c-7ff73b4df380)

위 join된 table를 보면 prereq table은 유지가 된채 course만 결합이 된 상태이고 CS-347 튜플이 가지지 않는 열은 null로 처리함 

아래 코드는 구현이지만 실제 실행했을 때, 결과는 다를 수 있음 

```ruby
select*
from course natural right join prereq;
```

<br/>

## Full Outer Join 결과 

![image](https://github.com/user-attachments/assets/490df678-d499-4348-9ed6-e6921954143a)

위 join된 table를 보면 두 table의 모든 튜플 정보는 유지하면서 join이 됨 

```ruby
select*
from course natural left join prereq

union

select*
from course natural right join prereq;
```




















































































































