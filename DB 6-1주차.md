## Transactions

만약 A 고객과 B 고객 사이 돈을 주고 받는 상황을 생각해보자 

A 고객이 B 고객에게 돈을 보냈는데 오류로 인해 B 고객 입장에서 돈이 오지 않는 경우가 발생할 수 있다 

이러한 상황을 방지하기 위해 도입된 개념이 Transactions이다

**Transactions** : 하나의 논리적 작업 단위로 실행되는 일련의 SQL 명령어 집합

이 정의가 무슨 의미인지 아래 예시를 통해 살펴보자 

<br/>

**예시**

```ruby
BEGIN;

UPDATE account SET balance = balance - 100 WHERE id = 1;  -- A 차감
UPDATE account SET balance = balance + 100 WHERE id = 2;  -- B 증가

COMMIT; (또는 rollback)
```

여기서 핵심 개념은 begin 과 commit(또는 rollback)이다 

- COMMIT : 모든 변경사항을 DB에 확정 저장

- ROLLBACK : 실행한 모든 SQL을 되돌림 (취소)

<br/>

실제로 이 개념은 다음과 같이 사용된다 

```ruby
BEGIN
  -- 트랜잭션 시작
  BEGIN
    -- A 계좌에서 100 차감
    UPDATE account SET balance = balance - 100 WHERE id = 1;

    -- B 계좌에 100 추가 (여기서 오류가 날 수도 있음)
    UPDATE account SET balance = balance + 100 WHERE id = 2;

    -- 모든 쿼리가 문제없다면 저장 확정
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      -- 오류 발생 시 전체 취소
      ROLLBACK;
      RAISE NOTICE '오류 발생으로 트랜잭션 롤백됨.';
  END;
END
$$;
```

<br/>

또한 transaction은 다음과 같은 성질을 만족해야한다 

**Atomic Transaction (원자성)** : 모두 실행되거나, 하나도 실행되지 않아야 한다

## 무결성 제약조건 (Integrity Constraints)

**무결성 제약조건**: 데이터베이스의 정확성과 일관성을 위해 잘못된 데이터 입력이나 손상을 사전에 차단하는 규칙

**장점**

- 사용자가 의도하지 않게 잘못된 데이터를 넣는 걸 방지해준다

- 데이터베이스를 항상 논리적으로 일관된 상태로 유지시켜준다

- 허용된 변경만 데이터에 반영되도록 해줌

<br/>

예시 

- 강사의 이름은 반드시 있어야 한다 -> not null

- 강사 ID는 유일해야 한다 -> unique

- 과목의 dept_name은 반드시 존재하는 학과여야 한다 -> FOREIGN KEY 제약조건

- 학과 예산은 0보다 커야 한다 -> check 제약 조건 

<br/>


## check 예시 

```ruby
## 예시1 
CREATE TABLE section (
  course_id     VARCHAR(8),
  sec_id        VARCHAR(8),
  semester      VARCHAR(6),
  year          NUMERIC(4,0),
  building      VARCHAR(15),
  room_number   VARCHAR(7),
  time_slot_id  VARCHAR(4),
  PRIMARY KEY (course_id, sec_id, semester, year),
  CHECK (semester IN ('Fall', 'Winter', 'Spring', 'Summer'))
);

## 예시 2
CREATE TABLE Student (
  student_id INT PRIMARY KEY,
  age INT,
  CHECK (age >= 18 AND age <= 30)
);
```


























